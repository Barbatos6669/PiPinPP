# GitHub Actions CI Workflow for PiPinPP
# This file tells GitHub how to automatically build and test our library

name: CI

# WHEN does this workflow run?
# - on every push to any branch
# - on every pull request
# This catches issues before they reach main branch
on:
  push:
    branches: [ "**" ]  # ** means "all branches"
  pull_request:
    branches: [ "**" ]

# WHAT does this workflow do?
jobs:
  # Job 1: Build and test the library
  build-and-test:
    name: Build (${{ matrix.build_type }}, ${{ matrix.os }}, ${{ matrix.arch }})
    
    # WHERE does this run?
    # GitHub provides free Ubuntu virtual machines for open source projects
    runs-on: ${{ matrix.os }}
    
    # STRATEGY: Test multiple configurations
    # This is called a "build matrix" - it runs the job multiple times
    # with different settings, helping us catch platform-specific issues
    strategy:
      # Don't cancel other jobs if one fails - we want to see all results
      fail-fast: false
      matrix:
        # Test on multiple Ubuntu versions to ensure compatibility
        os: [ubuntu-22.04, ubuntu-24.04]
        # Test both Debug (with symbols for debugging) and Release (optimized)
        build_type: [Debug, Release]
        # Test both x86_64 (GitHub's servers) and ARM64 (Raspberry Pi architecture)
        arch: [x86_64, aarch64]
        # IMPORTANT: Don't test ARM64 on old Ubuntu (compatibility issues)
        exclude:
          - os: ubuntu-22.04
            arch: aarch64
    
    # STEPS: What actually happens in this job
    steps:
      # Step 1: Get the code
      # actions/checkout is a pre-made GitHub Action that clones your repo
      # v4 is the version - always use latest stable version
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Set up QEMU for ARM emulation (only if testing ARM)
      # QEMU lets us run ARM binaries on x86_64 machines
      # Think of it as a "virtual Raspberry Pi" that runs on GitHub's servers
      - name: Set up QEMU
        if: matrix.arch == 'aarch64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/arm64
      
      # Step 3: Install dependencies (x86_64 native)
      # This is like what you did manually with apt-get
      # We need the same tools here that developers need on their Pi
      - name: Install dependencies (x86_64)
        if: matrix.arch == 'x86_64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libgpiod-dev \
            pkg-config \
            gpiod
        # Why these packages?
        # - build-essential: g++, make, and basic build tools
        # - cmake: our build system
        # - libgpiod-dev: GPIO library headers and development files
        # - pkg-config: helps other projects find our library
        # - gpiod: command-line GPIO tools
      
      # Step 4: Build and test on x86_64 (native)
      - name: Build and test (x86_64)
        if: matrix.arch == 'x86_64'
        run: |
          # Configure the build
          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
            -DPIPINPP_ENABLE_LOGGING=OFF \
            -DPIPINPP_WARNINGS_AS_ERRORS=ON \
            -DBUILD_TESTS=ON \
            -DBUILD_EXAMPLES=ON
          
          # Build everything
          cmake --build build --config ${{ matrix.build_type }} -j$(nproc)
          
          # Run tests (continue even if they fail - no GPIO hardware)
          cd build && ctest --output-on-failure --verbose || true
      
      # Step 5: Build and test on ARM64 (emulated via Docker)
      # This runs in an ARM64 Ubuntu container using QEMU emulation
      # It's slower but tests the actual Raspberry Pi architecture!
      - name: Build and test (ARM64)
        if: matrix.arch == 'aarch64'
        uses: docker://arm64v8/ubuntu:24.04
        with:
          args: >
            bash -c "
            apt-get update &&
            apt-get install -y build-essential cmake libgpiod-dev pkg-config gpiod &&
            cd /github/workspace &&
            cmake -B build
              -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
              -DPIPINPP_ENABLE_LOGGING=OFF
              -DPIPINPP_WARNINGS_AS_ERRORS=ON
              -DBUILD_TESTS=ON
              -DBUILD_EXAMPLES=ON &&
            cmake --build build --config ${{ matrix.build_type }} -j\$(nproc) &&
            cd build && ctest --output-on-failure --verbose || true
            "
        # EXPLANATION:
        # - docker://arm64v8/ubuntu:24.04 = Official ARM64 Ubuntu image
        # - QEMU translates ARM instructions to x86_64 on the fly
        # - /github/workspace = where GitHub mounts your code
        # - All commands run inside the ARM64 container
        # - This is THE SAME as running on a real Raspberry Pi!
      
      # Step 6: Test pkg-config integration (x86_64 only for now)
      # This verifies that other projects can find our library
      - name: Test pkg-config
        if: matrix.arch == 'x86_64'
        run: |
          # First, install our library to a temporary location
          cmake --install build --prefix /tmp/pipinpp-test
          
          # Tell pkg-config where to find our .pc file
          export PKG_CONFIG_PATH=/tmp/pipinpp-test/lib/pkgconfig:$PKG_CONFIG_PATH
          
          # Try to find our library - this should succeed
          pkg-config --exists pipinpp && echo "✓ pkg-config can find pipinpp"
          
          # Verify it reports the correct version
          pkg-config --modversion pipinpp
          
          # Show the compile flags (should include -I for headers)
          echo "Compile flags: $(pkg-config --cflags pipinpp)"
          
          # Show the link flags (should include -L and -lpipinpp)
          echo "Link flags: $(pkg-config --libs pipinpp)"
        # This test is important because many C++ projects use pkg-config
        # to find and link against libraries
      
      # Step 7: Build a test project using pkg-config (x86_64 only)
      # This simulates how a real user would use our library
      - name: Test external project integration
        if: matrix.arch == 'x86_64'
        run: |
          # Still need pkg-config to find our library
          export PKG_CONFIG_PATH=/tmp/pipinpp-test/lib/pkgconfig:$PKG_CONFIG_PATH
          
          # Create a minimal test program
          echo '#include "pin.hpp"' > /tmp/test_app.cpp
          echo '#include <iostream>' >> /tmp/test_app.cpp
          echo 'int main() {' >> /tmp/test_app.cpp
          echo '    std::cout << "PiPinPP integration test" << std::endl;' >> /tmp/test_app.cpp
          echo '    return 0;' >> /tmp/test_app.cpp
          echo '}' >> /tmp/test_app.cpp
          
          # Try to compile it using pkg-config
          # This is how a real user would compile their program
          g++ /tmp/test_app.cpp $(pkg-config --cflags --libs pipinpp) -o /tmp/test_app
          
          # Run it to make sure it doesn't crash
          /tmp/test_app
          
          echo "✓ External project can compile and link against PiPinPP"

  # Job 2: CodeQL security analysis (optional but recommended)
  codeql-analysis:
    name: CodeQL Security Scan
    runs-on: ubuntu-latest
    
    # PERMISSIONS: CodeQL needs permission to upload results
    permissions:
      actions: read
      contents: read
      security-events: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake libgpiod-dev
      
      # Initialize CodeQL - this sets up the C++ scanner
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: cpp
          # CodeQL will analyze C++ code for:
          # - Buffer overflows
          # - Memory leaks
          # - Null pointer dereferences
          # - SQL injection (if applicable)
          # - And many other security issues
      
      # Build the project so CodeQL can analyze it
      - name: Build for analysis
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Debug
          cmake --build build -j$(nproc)
      
      # Run the actual analysis
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        # Results appear in GitHub's Security tab
        # You'll get alerts if any security issues are found
