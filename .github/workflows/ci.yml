# GitHub Actions CI Workflow for PiPinPP
# This file tells GitHub how to automatically build and test our library

name: CI

# WHEN does this workflow run?
# - on every push to any branch
# - on every pull request
# This catches issues before they reach main branch
on:
  push:
    branches: [ "**" ]  # ** means "all branches"
  pull_request:
    branches: [ "**" ]

# WHAT does this workflow do?
jobs:
  # Job 1: Build and test the library
  build-and-test:
    name: Build (${{ matrix.build_type }}, ${{ matrix.os }}, ${{ matrix.arch }})
    
    # WHERE does this run?
    # GitHub provides free Ubuntu virtual machines for open source projects
    runs-on: ${{ matrix.os }}
    
    # STRATEGY: Test multiple configurations
    # This is called a "build matrix" - it runs the job multiple times
    # with different settings, helping us catch platform-specific issues
    strategy:
      # Don't cancel other jobs if one fails - we want to see all results
      fail-fast: false
      matrix:
        # Test on multiple Ubuntu versions to ensure compatibility
        os: [ubuntu-22.04, ubuntu-24.04]
        # Test both Debug (with symbols for debugging) and Release (optimized)
        build_type: [Debug, Release]
        # Test both x86_64 (GitHub's servers) and ARM64 (Raspberry Pi architecture)
        arch: [x86_64, aarch64]
        # IMPORTANT: Don't test ARM64 on old Ubuntu (compatibility issues)
        exclude:
          - os: ubuntu-22.04
            arch: aarch64
    
    # STEPS: What actually happens in this job
    steps:
      # Step 1: Get the code
      # actions/checkout is a pre-made GitHub Action that clones your repo
      # v4 is the version - always use latest stable version
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Set up QEMU for ARM emulation (only if testing ARM)
      # QEMU lets us run ARM binaries on x86_64 machines
      # Think of it as a "virtual Raspberry Pi" that runs on GitHub's servers
      - name: Set up QEMU
        if: matrix.arch == 'aarch64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/arm64
      
      # Step 3: Install base dependencies (x86_64 native)
      - name: Install base dependencies (x86_64)
        if: matrix.arch == 'x86_64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            pkg-config \
            git \
            autoconf \
            autoconf-archive \
            automake \
            libtool \
            python3 \
            python3-setuptools
        # Note: We DON'T install libgpiod-dev from apt because it's v1.x
        # We'll build v2.x from source in the next step
      
      # Step 4: Build and install libgpiod v2 from source (x86_64)
      # Ubuntu repos only have v1.x, but our code uses v2 API
      # This step downloads, builds, and installs libgpiod 2.2.1
      - name: Build libgpiod v2 (x86_64)
        if: matrix.arch == 'x86_64'
        run: |
          # Install additional build dependencies for libgpiod
          sudo apt-get install -y \
            linux-headers-generic \
            libkmod-dev \
            libudev-dev
          
          # Clone libgpiod v2.2.1 (the version your Pi has)
          git clone --depth 1 --branch v2.2.1 \
            https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git \
            /tmp/libgpiod
          
          cd /tmp/libgpiod
          
          # Build using autotools
          ./autogen.sh --enable-tools=yes --prefix=/usr --disable-bindings-cxx --disable-bindings-python
          make -j$(nproc)
          sudo make install
          sudo ldconfig
          
          # Verify installation
          pkg-config --modversion libgpiod
          echo "✓ libgpiod v2 installed successfully"
        # Why this matters:
        # - Your code was written for libgpiod v2 API
        # - GitHub's Ubuntu images only have v1 in repos
        # - Building from source ensures we get v2.2.1
        # - This matches what's on your actual Raspberry Pi!
        # - We disable C++ and Python bindings (not needed, faster build)
      
      # Step 5: Build and test PiPinPP on x86_64 (native)
      - name: Build and test (x86_64)
        if: matrix.arch == 'x86_64'
        run: |
          # Configure the build
          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
            -DPIPINPP_ENABLE_LOGGING=OFF \
            -DPIPINPP_WARNINGS_AS_ERRORS=ON \
            -DBUILD_TESTS=ON \
            -DBUILD_EXAMPLES=ON
          
          # Build everything
          cmake --build build --config ${{ matrix.build_type }} -j$(nproc)
          
          # Run tests (excluding hardware-dependent tests)
          # basic_test and thread_safety_test require /dev/gpiochip0 which doesn't exist in CI
          # We still run timing_test and exception_test which don't need hardware
          cd build && ctest --output-on-failure --verbose -E "basic_test|thread_safety_test" || true
      
      # Step 6: Build and test on ARM64 (emulated via Docker)
      # This runs in an ARM64 Ubuntu container using QEMU emulation
      # It's slower but tests the actual Raspberry Pi architecture!
      - name: Build and test (ARM64)
        if: matrix.arch == 'aarch64'
        run: |
          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            arm64v8/ubuntu:24.04 \
            bash -c "
              set -e
              apt-get update
              apt-get install -y build-essential cmake pkg-config git autoconf autoconf-archive automake libtool python3 python3-setuptools linux-headers-generic libkmod-dev libudev-dev
              
              # Build libgpiod v2.2.1 from source (same as x86_64 step)
              git clone --depth 1 --branch v2.2.1 https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git /tmp/libgpiod
              cd /tmp/libgpiod
              ./autogen.sh --enable-tools=yes --prefix=/usr --disable-bindings-cxx --disable-bindings-python
              make -j\$(nproc)
              make install
              ldconfig
              
              # Now build PiPinPP
              cd /workspace
              cmake -B build \
                -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
                -DPIPINPP_ENABLE_LOGGING=OFF \
                -DPIPINPP_WARNINGS_AS_ERRORS=ON \
                -DBUILD_TESTS=ON \
                -DBUILD_EXAMPLES=ON
              cmake --build build --config ${{ matrix.build_type }} -j\$(nproc)
              cd build && ctest --output-on-failure --verbose -E 'basic_test|thread_safety_test' || true
            "
        # EXPLANATION:
        # - docker run --platform linux/arm64 = Force ARM64 architecture
        # - -v mounts your code into the container at /workspace
        # - -w sets working directory to /workspace
        # - arm64v8/ubuntu:24.04 = Official ARM64 Ubuntu image
        # - We build libgpiod v2 from source (just like x86_64)
        # - Disable C++/Python bindings for faster build
        # - QEMU translates ARM instructions to x86_64 on the fly
        # - This is THE SAME as running on a real Raspberry Pi!
      
      # Step 7: Test pkg-config integration (x86_64 only for now)
      # This verifies that other projects can find our library
      - name: Test pkg-config
        if: matrix.arch == 'x86_64'
        run: |
          # First, install our library to a temporary location
          cmake --install build --prefix /tmp/pipinpp-test
          
          # Tell pkg-config where to find our .pc file
          export PKG_CONFIG_PATH=/tmp/pipinpp-test/lib/pkgconfig:$PKG_CONFIG_PATH
          
          # Try to find our library - this should succeed
          pkg-config --exists pipinpp && echo "✓ pkg-config can find pipinpp"
          
          # Verify it reports the correct version
          pkg-config --modversion pipinpp
          
          # Show the compile flags (should include -I for headers)
          echo "Compile flags: $(pkg-config --cflags pipinpp)"
          
          # Show the link flags (should include -L and -lpipinpp)
          echo "Link flags: $(pkg-config --libs pipinpp)"
        # This test is important because many C++ projects use pkg-config
        # to find and link against libraries
      
      # Step 8: Build a test project using pkg-config (x86_64 only)
      # This simulates how a real user would use our library
      - name: Test external project integration
        if: matrix.arch == 'x86_64'
        run: |
          # Still need pkg-config to find our library
          export PKG_CONFIG_PATH=/tmp/pipinpp-test/lib/pkgconfig:$PKG_CONFIG_PATH
          
          # Create a minimal test program
          echo '#include "pin.hpp"' > /tmp/test_app.cpp
          echo '#include <iostream>' >> /tmp/test_app.cpp
          echo 'int main() {' >> /tmp/test_app.cpp
          echo '    std::cout << "PiPinPP integration test" << std::endl;' >> /tmp/test_app.cpp
          echo '    return 0;' >> /tmp/test_app.cpp
          echo '}' >> /tmp/test_app.cpp
          
          # Try to compile it using pkg-config
          # This is how a real user would compile their program
          g++ /tmp/test_app.cpp $(pkg-config --cflags --libs pipinpp) -o /tmp/test_app
          
          # Run it to make sure it doesn't crash
          /tmp/test_app
          
          echo "✓ External project can compile and link against PiPinPP"

  # Job 2: CodeQL security analysis (optional but recommended)
  codeql-analysis:
    name: CodeQL Security Scan
    runs-on: ubuntu-latest
    
    # PERMISSIONS: CodeQL needs permission to upload results
    permissions:
      actions: read
      contents: read
      security-events: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake libgpiod-dev
      
      # Initialize CodeQL - this sets up the C++ scanner
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: cpp
          # CodeQL will analyze C++ code for:
          # - Buffer overflows
          # - Memory leaks
          # - Null pointer dereferences
          # - SQL injection (if applicable)
          # - And many other security issues
      
      # Build the project so CodeQL can analyze it
      - name: Build for analysis
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Debug
          cmake --build build -j$(nproc)
      
      # Run the actual analysis
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        # Results appear in GitHub's Security tab
        # You'll get alerts if any security issues are found
