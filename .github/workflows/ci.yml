# GitHub Actions CI Workflow for PiPinPP
# This file tells GitHub how to automatically build and test our library

name: CI

# WHEN does this workflow run?
# - on every push to any branch
# - on every pull request
# This catches issues before they reach main branch
on:
  push:
    branches: [ "**" ]  # ** means "all branches"
  pull_request:
    branches: [ "**" ]

# WHAT does this workflow do?
jobs:
  # Job 1: Cloud builds - Fast compilation validation
  cloud-build:
    name: Cloud Build (${{ matrix.build_type }}, ${{ matrix.os }})
    
    # WHERE does this run?
    # GitHub provides free Ubuntu virtual machines for open source projects
    runs-on: ${{ matrix.os }}
    
    # STRATEGY: Test multiple configurations
    # This is called a "build matrix" - it runs the job multiple times
    # with different settings, helping us catch platform-specific issues
    strategy:
      # Don't cancel other jobs if one fails - we want to see all results
      fail-fast: false
      matrix:
        # Test on multiple Ubuntu versions to ensure compatibility
        os: [ubuntu-22.04, ubuntu-24.04]
        # Test both Debug (with symbols for debugging) and Release (optimized)
        build_type: [Debug, Release]
    
    # STEPS: What actually happens in this job
    steps:
      # Step 1: Get the code
      # actions/checkout is a pre-made GitHub Action that clones your repo
      # v4 is the version - always use latest stable version
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Install base dependencies
      - name: Install base dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            pkg-config \
            git \
            autoconf \
            autoconf-archive \
            automake \
            libtool \
            python3 \
            python3-setuptools
        # Note: We DON'T install libgpiod-dev from apt because it's v1.x
        # We'll build v2.x from source in the next step
      
      # Step 3: Build and install libgpiod v2 from source
      # Ubuntu repos only have v1.x, but our code uses v2 API
      # This step downloads, builds, and installs libgpiod 2.2.1
      - name: Build libgpiod v2
        run: |
          # Install additional build dependencies for libgpiod
          sudo apt-get install -y \
            linux-headers-generic \
            libkmod-dev \
            libudev-dev
          
          # Clone libgpiod v2.2.1 (the version your Pi has)
          git clone --depth 1 --branch v2.2.1 \
            https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git \
            /tmp/libgpiod
          
          cd /tmp/libgpiod
          
          # Build using autotools
          ./autogen.sh --enable-tools=yes --prefix=/usr --disable-bindings-cxx --disable-bindings-python
          make -j$(nproc)
          sudo make install
          sudo ldconfig
          
          # Verify installation
          pkg-config --modversion libgpiod
          echo "✓ libgpiod v2 installed successfully"
        # Why this matters:
        # - Your code was written for libgpiod v2 API
        # - GitHub's Ubuntu images only have v1 in repos
        # - Building from source ensures we get v2.2.1
        # - This matches what's on your actual Raspberry Pi!
        # - We disable C++ and Python bindings (not needed, faster build)
      
      # Step 4: Build and test PiPinPP
      - name: Build and test
        run: |
          # Configure the build
          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
            -DPIPINPP_ENABLE_LOGGING=OFF \
            -DPIPINPP_WARNINGS_AS_ERRORS=ON \
            -DBUILD_TESTS=ON \
            -DBUILD_EXAMPLES=ON
          
          # Build everything
          cmake --build build --config ${{ matrix.build_type }} -j$(nproc)
          
          # Run tests (excluding hardware-dependent tests)
          # basic_test and thread_safety_test require /dev/gpiochip0 which doesn't exist in CI
          # We still run timing_test and exception_test which don't need hardware
          cd build && ctest --output-on-failure --verbose -E "basic_test|thread_safety_test" || true
      
      # Step 5: Test pkg-config integration
      # This verifies that other projects can find our library
      - name: Test pkg-config
        run: |
          # First, install our library to a temporary location
          cmake --install build --prefix /tmp/pipinpp-test
          
          # Tell pkg-config where to find our .pc file
          export PKG_CONFIG_PATH=/tmp/pipinpp-test/lib/pkgconfig:$PKG_CONFIG_PATH
          
          # Try to find our library - this should succeed
          pkg-config --exists pipinpp && echo "✓ pkg-config can find pipinpp"
          
          # Verify it reports the correct version
          pkg-config --modversion pipinpp
          
          # Show the compile flags (should include -I for headers)
          echo "Compile flags: $(pkg-config --cflags pipinpp)"
          
          # Show the link flags (should include -L and -lpipinpp)
          echo "Link flags: $(pkg-config --libs pipinpp)"
        # This test is important because many C++ projects use pkg-config
        # to find and link against libraries
      
      # Step 6: Build a test project using pkg-config
      # This simulates how a real user would use our library
      - name: Test external project integration
        run: |
          # Still need pkg-config to find our library
          export PKG_CONFIG_PATH=/tmp/pipinpp-test/lib/pkgconfig:$PKG_CONFIG_PATH
          
          # Create a minimal test program
          echo '#include "pin.hpp"' > /tmp/test_app.cpp
          echo '#include <iostream>' >> /tmp/test_app.cpp
          echo 'int main() {' >> /tmp/test_app.cpp
          echo '    std::cout << "PiPinPP integration test" << std::endl;' >> /tmp/test_app.cpp
          echo '    return 0;' >> /tmp/test_app.cpp
          echo '}' >> /tmp/test_app.cpp
          
          # Try to compile it using pkg-config
          # This is how a real user would compile their program
          g++ /tmp/test_app.cpp $(pkg-config --cflags --libs pipinpp) -o /tmp/test_app
          
          # Run it to make sure it doesn't crash
          /tmp/test_app
          
          echo "✓ External project can compile and link against PiPinPP"

  # Job 2: Hardware testing on actual Raspberry Pi (OPTIONAL)
  # This job will be skipped if no self-hosted runner is available
  # To enable: Follow docs/SELF_HOSTED_RUNNER.md to set up your Pi
  hardware-test:
    name: Hardware Test (Raspberry Pi) [Optional]
    runs-on: self-hosted
    
    # Only run hardware tests on main branch or when manually triggered
    # This prevents every PR from running on your Pi
    if: false  # Disabled by default - change to 'github.ref == refs/heads/main' when runner is ready
    
    # UNCOMMENT THIS LINE AFTER SETTING UP PI RUNNER:
    # if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Build PiPinPP
        run: |
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Release \
            -DPIPINPP_ENABLE_LOGGING=OFF \
            -DPIPINPP_WARNINGS_AS_ERRORS=ON \
            -DBUILD_TESTS=ON \
            -DBUILD_EXAMPLES=ON
          cmake --build build -j$(nproc)
      
      - name: Run ALL tests (including hardware tests)
        run: |
          cd build
          # Run ALL tests - your Pi has real GPIO hardware!
          ctest --output-on-failure --verbose
        # This runs:
        # ✓ basic_test - accesses /dev/gpiochip0 (real GPIO)
        # ✓ thread_safety_test - concurrent GPIO operations
        # ✓ timing_test - precise timing measurements
        # ✓ exception_test - error handling
      
      - name: Test examples compile
        run: |
          echo "✓ Examples built successfully"
          ls -lh build/examples/
        # We don't run examples (they'd toggle GPIO pins)
        # But we verify they compile on real hardware

  # Job 3: CodeQL security analysis (optional but recommended)
  codeql-analysis:
    name: CodeQL Security Scan
    runs-on: ubuntu-latest
    
    # PERMISSIONS: CodeQL needs permission to upload results
    permissions:
      actions: read
      contents: read
      security-events: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake libgpiod-dev
      
      # Initialize CodeQL - this sets up the C++ scanner
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: cpp
          # CodeQL will analyze C++ code for:
          # - Buffer overflows
          # - Memory leaks
          # - Null pointer dereferences
          # - SQL injection (if applicable)
          # - And many other security issues
      
      # Build the project so CodeQL can analyze it
      - name: Build for analysis
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Debug
          cmake --build build -j$(nproc)
      
      # Run the actual analysis
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        # Results appear in GitHub's Security tab
        # You'll get alerts if any security issues are found
